//==============================================================//
//                                                              //
//       This file is generated by axNodeGen                    //
//                                                              //
//==============================================================//

#include "GEO_Bend.h"

namespace Anon{ 

struct GEO_Bend::Spec : public AnonObjectSpec {
	struct Field_angle : public axFieldInfo {
		Field_angle(axType* type) : axFieldInfo(type, &GEO_Bend::_angle, "angle", "Angle") {
			static SliderAttribute Slider(-180,180);
			static axAttribute* attrs[] = {&Slider};
			_attributes = axSpan_make(attrs);
		}
		virtual void onSetToDefaultValue(axValuePtr& data) const final {
			data.value<double>() = double();
		};
	};
	Field_angle field_angle;

	struct Field_origin : public axFieldInfo {
		Field_origin(axType* type) : axFieldInfo(type, &GEO_Bend::_origin, "origin", "Origin") {
		}
		virtual void onSetToDefaultValue(axValuePtr& data) const final {
			data.value<Vec3d>() = Vec3d(0,0,0);
		};
	};
	Field_origin field_origin;

	struct Field_direction : public axFieldInfo {
		Field_direction(axType* type) : axFieldInfo(type, &GEO_Bend::_direction, "direction", "Direction") {
		}
		virtual void onSetToDefaultValue(axValuePtr& data) const final {
			data.value<Vec3d>() = Vec3d(0,0,1);
		};
	};
	Field_direction field_direction;

	struct Field_upVector : public axFieldInfo {
		Field_upVector(axType* type) : axFieldInfo(type, &GEO_Bend::_upVector, "upVector", "Up Vector") {
		}
		virtual void onSetToDefaultValue(axValuePtr& data) const final {
			data.value<Vec3d>() = Vec3d(0,1,0);
		};
	};
	Field_upVector field_upVector;

	struct Field_length : public axFieldInfo {
		Field_length(axType* type) : axFieldInfo(type, &GEO_Bend::_length, "length", "Length") {
		}
		virtual void onSetToDefaultValue(axValuePtr& data) const final {
			data.value<double>() = 1;
		};
	};
	Field_length field_length;

	static const Spec* s_instance;

	axArray<axFieldInfo*, 16> _fields;

	Spec(axType* type)
		: AnonObjectSpec(type)
		, field_angle(type)
		, field_origin(type)
		, field_direction(type)
		, field_upVector(type)
		, field_length(type)
	{
		s_instance = this;
		axInt ownFieldCount = 5;
		auto baseFieldCount = type->_baseClass->fields().size();
		_fields.resize(ownFieldCount + baseFieldCount);
		_fields.slice(0, baseFieldCount).copyValues(type->_baseClass->fields());
		auto ownFields = _fields.sliceFrom(baseFieldCount);

		ownFields[0] = &field_angle;
		ownFields[1] = &field_origin;
		ownFields[2] = &field_direction;
		ownFields[3] = &field_upVector;
		ownFields[4] = &field_length;

		type->_fields    = _fields.span();
		type->_ownFields = ownFields;
	}

};

void GEO_Bend::s_initRtti(axType* type) {
	static Spec spec(type);
}

const GEO_Bend::Spec* GEO_Bend::Spec::s_instance = nullptr;

void GEO_Bend::onInitProps() {
	Base::onInitProps();
	auto* spec = Spec::s_instance;
	_initProp(spec->field_angle, _angle);
	_initProp(spec->field_origin, _origin);
	_initProp(spec->field_direction, _direction);
	_initProp(spec->field_upVector, _upVector);
	_initProp(spec->field_length, _length);
}

bool GEO_Bend::onReadJsonProp(axJsonReader& rd_) {
	bool _ret = Base::onReadJsonProp(rd_);
	if (rd_.isMember("angle")) { rd_.readValue(_angle); _ret = true; }
	if (rd_.isMember("origin")) { rd_.readValue(_origin); _ret = true; }
	if (rd_.isMember("direction")) { rd_.readValue(_direction); _ret = true; }
	if (rd_.isMember("upVector")) { rd_.readValue(_upVector); _ret = true; }
	if (rd_.isMember("length")) { rd_.readValue(_length); _ret = true; }
	return _ret;
}

void GEO_Bend::onWriteJsonProp(axJsonWriter& wr_) const {
	Base::onWriteJsonProp(wr_);
	wr_.writeMember("angle", _angle);
	wr_.writeMember("origin", _origin);
	wr_.writeMember("direction", _direction);
	wr_.writeMember("upVector", _upVector);
	wr_.writeMember("length", _length);
}

} // namespace 
