#include "Generator.h"

namespace axNodeGen {

Generator::Generator() {

}

void Generator::gen(axStrView filename) {
	_parser.readFile(filename, _typeDB);

	if (!_typeDB.types.size()) {
		return;
	}

	auto headerMessage = axStrLiteral(	"//==============================================================//\n"
										"//                                                              //\n"
										"//       This file is generated by axNodeGen                    //\n"
										"//                                                              //\n"
										"//==============================================================//\n\n");

	for (auto& type : _typeDB.types.values()) {
		_outImpl = headerMessage;

		gen_type(type);

		auto dir = axPath::dirname(filename);

		axString typeFilename(type.name);
		typeFilename.replaceChars(':', '_');

		if (_outImpl) {
			axTempString outFilename(dir, "/", typeFilename, "._gen.cpp");
			axFile::writeFileIfChanged(outFilename, _outImpl, true, false);
		}
	}
}

void Generator::gen_type(TypeInfo& type) {
	_outImpl.append("#include \"", type.name, ".h\"\n\n");
	_outImpl.append(type.openNamespaceScope);

	_outImpl.append("struct ", type.name, "::Spec : public AnonObjectSpec {\n");

	for (auto& prop : type.props.values()) {
		_outImpl.append("\t""struct Field_", prop.name, " : public axFieldInfo {\n");

		_outImpl.append("\t\t""Field_", prop.name, "(axType* type)");

	//---- constructor
		_outImpl.append(" : axFieldInfo(type, &", type.name, "::", prop.varName, ", \"", prop.name, "\", \"", prop.displayName, "\") {\n");
		if (prop.attributes.size()) {
			for (auto& attr : prop.attributes) {
				_outImpl.append("\t\t\t", "static ", attr.name, "Attribute ", attr.name, attr.defaultValue, ";\n");
			}

			_outImpl.append("\t\t\t""static axAttribute* attrs[] = {");
			axInt i = 0;
			for (auto& attr : prop.attributes) {
				if (i > 0) _outImpl.append(", ");
				_outImpl.append("&", attr.name);
				i++;
			}
			_outImpl.append("};\n");
			_outImpl.append("\t\t\t""_attributes = axSpan_make(attrs);\n");
		}

		_outImpl.append("\t\t""}\n");

	//----- onSetToDefaultValue
		_outImpl.append("\t\t""virtual void onSetToDefaultValue(axValuePtr& data) const final {\n");
		_outImpl.append("\t\t\t""data.value<", prop.typeName, ">() = "
								, prop.defaultValue ? prop.defaultValue : axString(prop.typeName
								, "()"), ";\n");

		_outImpl.append("\t\t};\n");

		_outImpl.append("\t};\n");
		_outImpl.append("\t","Field_", prop.name, " field_", prop.name,";\n\n");
	}

	_outImpl.append("\t""static const Spec* s_instance;\n\n");
	_outImpl.append("\t""axArray<axFieldInfo*, 16> _fields;\n\n");

	_outImpl.append("\t""Spec(axType* type)\n");
	_outImpl.append("\t\t"": AnonObjectSpec(type)\n");
	for (auto& prop : type.props.values()) {
		_outImpl.append("\t\t"", field_", prop.name,"(type)\n");
	}
	_outImpl.append("\t""{\n");
	_outImpl.append("\t\t""s_instance = this;\n");
	_outImpl.appendFormat("\t\t""axInt ownFieldCount = {?};\n", type.props.size());
	_outImpl.append("\t\t""auto baseFieldCount = type->_baseClass->fields().size();\n");
	_outImpl.append("\t\t""_fields.resize(ownFieldCount + baseFieldCount);\n");
	_outImpl.append("\t\t""_fields.slice(0, baseFieldCount).copyValues(type->_baseClass->fields());\n");
	_outImpl.append("\t\t""auto ownFields = _fields.sliceFrom(baseFieldCount);\n");
	_outImpl.append("\n");

	axInt i = 0;
	for (auto& prop : type.props.values()) {
		_outImpl.appendFormat("\t\t""ownFields[{?}] = &field_{?};\n", i, prop.name);
		i++;
	}
	_outImpl.append("\n");
	_outImpl.append("\t\t""type->_fields    = _fields.span();\n");
	_outImpl.append("\t\t""type->_ownFields = ownFields;\n");
	_outImpl.append("\t""}\n\n");

	_outImpl.append("};\n\n");

	_outImpl.append("void ", type.name, "::s_initRtti(axType* type) {\n");
	_outImpl.append("\t""static Spec spec(type);\n");
	_outImpl.append("}\n\n");

	_outImpl.append("const ", type.name, "::Spec* ", type.name, "::Spec::s_instance = nullptr;\n\n");

	{
		_outImpl.append("void ", type.name, "::onInitProps() {\n");
		_outImpl.append("\t""Base::onInitProps();\n");
		if (type.props.size()) {
			_outImpl.append("\t""auto* spec = Spec::s_instance;\n");
			for (auto& prop : type.props.values()) {
				_outImpl.append("\t""_initProp(spec->field_", prop.name, ", ", prop.varName,");\n");
			}
		}
		_outImpl.append("}\n\n");
	}
	{
		_outImpl.append("bool ", type.name, "::onReadJsonProp(axJsonReader& rd_) {\n");
		_outImpl.append("\t""bool _ret = Base::onReadJsonProp(rd_);\n");
		for (auto& prop : type.props.values()) {
			if (prop.hasAttr.dontSave) continue;
			_outImpl.append("\t""if (rd_.isMember(\"", prop.name, "\")) { ");
			_outImpl.append("rd_.readValue(", prop.varName,"); ");
			_outImpl.append("_ret = true; }\n");
		}
		_outImpl.append("\t""return _ret;\n");
		_outImpl.append("}\n\n");
	}
	{
		_outImpl.append("void ", type.name, "::onWriteJsonProp(axJsonWriter& wr_) const {\n");
		_outImpl.append("\t""Base::onWriteJsonProp(wr_);\n");
		for (auto& prop : type.props.values()) {
			if (prop.hasAttr.dontSave) continue;
			_outImpl.append("\t""wr_.writeMember(\"", prop.name, "\", ", prop.varName,");\n");
		}
		_outImpl.append("}\n\n");
	}

	_outImpl.append(type.closeNamespaceScope);
}

} //namespace